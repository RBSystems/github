#! /usr/bin/env python

'''
Program: generate and submit pbs files for RMG
         save rmg.in/supercell.in for later debug
    zjyx, @2017/02, ORNL

ChangeLogs:
    1. remove queue tags, which will be determined by walltime and host
        automatically.
    2. change param's 'type' from type+_type+__type to [type, type];
       change format of str to 'str'

TODO:
    use set and get method for pbs class
    use unchangeable class for param_prop--prohibit possible mischange

USAGE:
    pbstool ($pbs.conf file)
    where pbstool should be in system's $PATH, and $pbs.conf is the control
    file for this script, which should be in the following format:
    -----------------------------------------------------------------------
    # required
    NODES       = 16
    TIME        = 100 20 # in units of hrs, mins
    EXEINPUT    = rmg.in
    EXEPATH     = /home/z8j/bin/rmg-cpu
    THREADS     = 2
    
    # optional
    NAME        = surface-pbe221-rlx
    IS_SUBMIT   = true
    QUEUE       = None
    ------------------------------------------------------------------------
    If $pbs.conf not defined, pbs.conf will be read by default.

'''

import os
import sys

# params properties
# if param is list, then type should be [1D type, 2D type]
param_prop = {
    'nodes':     {'required': True,  'type': 'int',   'default': None},
    'time' :     {'required': True,  'type': ['list', 'int'], 'default': None},
    'exeinput':  {'required': True,  'type': 'str',   'default': None},
    'exepath':   {'required': True,  'type': 'str',   'default': None},
    'threads':   {'required': False, 'type': 'int',   'default': 1},
    'name':      {'required': False, 'type': 'str',   'default': 'test'},
    'queue':     {'required': False, 'type': 'str',   'default': 'debug'},
    'is_submit': {'required': False, 'type': 'bool',  'default': True},
    'cores':     {'required': False, 'type': 'int',   'default': None}
    }

# system properties
sys_prop = {
    'Cades': {'all_queues': ['batch', 'long'], 'time_threshold': 30},
    'BlueWaters': {'all_queues': ['debug', 'normal', 'high'], 'time_threshold': 30}
    }

class InitEnv:
    def __init__(self):
        self._user = None
        self._host = None
        self._pwd  = None
        self._home_path = None

        self._set_all()

    def _set_all(self):
        self._set_user()
        self._set_host()
        self._set_pwd()
        self._set_home_path()

    def _set_user(self):
        import getpass
        self._user = getpass.getuser()

    def get_user(self):
        return self._user

    def _set_host(self):
        import socket
        hostname = socket.gethostname()
        if 'or-condo' in hostname:
            self._host = 'Cades'
        elif 'h2o' in hostname:
            self._host = 'BlueWaters'
        elif 'titan' in hostname:
            self._host = 'Titan'
        else:
            print 'Unknow host, exit.\n'

    def get_host(self):
        return self._host

    def _set_pwd(self):
        self._pwd = os.getcwd()

    def get_pwd(self):
        return self._pwd

    def _set_home_path(self):
        self._home_path = os.path.expanduser('~')

    def get_home_path(self):
        return self._home_path

# add set and get functions here, cause it may be modified
class ConfParser:
    def __init__(self, filename=None):
        self._confs = { 'nodes':    param_prop['nodes']['default'],
                        'time':     param_prop['time']['default'],
                        'exeinput': param_prop['exeinput']['default'],
                        'exepath':  param_prop['exepath']['default']
        }

        self._params = {}

        if filename is not None:
            self.read_file(filename)

        self.parse_conf()

    def setting_error(self, msg):
        print(msg)
        print("Please check the setting tags.")
        sys.exit(1)

    def read_file(self, filename):
        confs = self._confs
        with open(filename, 'rb') as f:
            lines_conf = f.readlines()
        for line in lines_conf:
            line_tmp = line.split('#')[0]
            if line_tmp == '':
                continue
            if line_tmp.find('=') != -1:
                left, right = [x.strip().lower() for x in line_tmp.split('=')]
                confs[left] = right

    def parse_conf(self):
        confs = self._confs

        for conf_key in confs.keys():
            if conf_key == 'nodes':
                self.set_param('nodes', confs['nodes'])
            elif conf_key == 'time':
                self.set_param('time', confs['time'])
            elif conf_key == 'exeinput':
                self.set_param('exeinput', confs['exeinput'])
            elif conf_key == 'exepath':
                self.set_param('exepath', confs['exepath'])
            elif conf_key == 'threads':
                self.set_param('threads', confs['threads'])
            elif conf_key == 'name':
                self.set_param('name', confs['name'])
            elif conf_key == 'is_submit':
                self.set_param('is_submit', confs['is_submit'])
            elif conf_key == 'queue':
                self.set_param('queue', confs['queue'])
            else:
                print("Warning! Unrecoginized settings: %s"% conf_key)

    def set_param(self, key, val):
        _param = param_prop[key]
        # TODO: need to detect if a default value has been modified intendly
        if _param['required'] and val == _param['default']:
            msg = "Error: required tags %s not found."% key.upper()
            self.setting_error(msg)

        if not isinstance(_param['type'], list):
            if _param['type'].lower() == 'str':
                self._params[key] = str(val)
            elif _param['type'].lower() == 'int':
                self._params[key] = int(val)
            elif _param['type'].lower() == 'float':
                self._params[key] = float(val)
            elif _param['type'].lower() == 'bool':
                if val.lower() == 'false':
                    self._params[key] = False
                elif val.lower() == 'true':
                    self._params[key] = True
        elif len(_param['type']) == 2:
            if _param['type'][0] == 'list':
                _2type = eval(_param['type'][1])
                self._params[key] = [_2type(x) for x in val.split()]
        else:
            msg = "Error: %s type tag could not be identified."% key.upper()
            self.setting_error(msg)

    def validate_param(self):
        pass

# check if settings make sense, and correct them
def validate_params(pbs_conf, init_env):
    threads  = pbs_conf._params['threads']
    exeinput = pbs_conf._params['exeinput']
    exepath  = pbs_conf._params['exepath']
    queue    = pbs_conf._params['queue']
    time     = pbs_conf._params['time']
    name     = pbs_conf._params['name']
    is_submit= pbs_conf._params['is_submit']

    if not is_submit:
        print "Debug mode, job will not be submitted.\n"

    name += '@' + init_env.get_pwd()

    if 32%(threads):
        msg = "Error: OMP_NUM_THREADS is wrongly set, exit."
        pbs_conf.setting_error(msg)

    if not os.path.isfile(exepath):
        msg = "Error: RMG executable file(%s) does not exist, exit."% exepath
        pbs_conf.setting_error(msg)

    if not os.path.isfile(exeinput):
        msg = "Error: RMG input file(%s) not found, exit."% exeinput
        pbs_conf.setting_error(msg)
    
    if init_env.get_host() == 'BlueWaters':
        all_queues = ['debug', 'normal', 'high']
        if queue != 'none' and queue not in all_queues:
            msg = "Queue error, exit."
            pbs_conf.setting_error(msg)
        # ignore if queue is high
        if queue != 'high':
            if time[0]*60+time[1] <= 30:
                queue = all_queues[0]
                print "Walltime is under 30 mins, queue is set to %s.\n"% queue
            else:
                queue = all_queues[1]
                print "Walltime exceeds 30 mins, queue is set to %s.\n"% queue
    elif init_env.get_host() == 'Cades':
        all_queues = ['batch', 'long']
        if queue != 'none' and queue not in all_queues:
            msg = "Queue error, exit."
            pbs_conf.setting_error(msg)
        if time[0] > 48:
            queue = all_queues[1]
            print "Walltime exceeds 48 hrs, queue is set to %s.\n"% queue
        else:
            queue = all_queues[0]
            print "Walltime is under 48 hrs, queue is set to %s.\n"% queue

    # consider use set and get method here
    pbs_conf._params['threads']  = threads    
    pbs_conf._params['exeinput'] = exeinput  
    pbs_conf._params['queue']    = queue      
    pbs_conf._params['time']     = time       
    pbs_conf._params['name']     = name       


def write_pbs(init_env, pbs_conf):
    threads  = pbs_conf._params['threads']
    nodes    = pbs_conf._params['nodes']
    time     = pbs_conf._params['time']
    name     = pbs_conf._params['name']
    queue    = pbs_conf._params['queue']
    exepath  = pbs_conf._params['exepath']
    exeinput = pbs_conf._params['exeinput']

    pwd = init_env.get_pwd()
    ppn_use     = divmod(32, threads)[0]
    cores       = int(nodes*32/threads)
    time_pbs    = "%02d:%02d:00"%(time[0], time[1])
    
    pbs_dict = {'queue':        queue,
                'time':         time_pbs,
                'nodes':        nodes,
                'name':         name,
                'threads':      threads,
                'pwd':          pwd,
                'cores':        cores,
                'exepath':      exepath,
                'exeinput':     exeinput,
                'ppn_use':      ppn_use}

    if init_env.get_host() == "Cades":
        lines_pbs = ""
        lines_pbs += "#!/bin/bash\n"
        lines_pbs += "\n"
        lines_pbs += "#PBS -A sns\n"
        lines_pbs += "#PBS -q %(queue)s\n"% pbs_dict
        lines_pbs += "#PBS -m ea\n"
        lines_pbs += "#PBS -M zjyx1991@foxmail.com\n"
        lines_pbs += "#PBS -j oe\n"
        lines_pbs += "#PBS -l qos=condo\n"
        lines_pbs += "#PBS -W group_list=cades-virtues\n"
        lines_pbs += "#PBS -l walltime=%(time)s\n" % pbs_dict
        lines_pbs += "#PBS -l nodes=%(nodes)d:ppn=32\n"% pbs_dict
        lines_pbs += "#PBS -N %(name)s\n" % pbs_dict
        lines_pbs += "\n"
        lines_pbs += "module load PE-gnu\n"
        lines_pbs += "module list\n"
        lines_pbs += "\n"
        lines_pbs += "export OMP_NUM_THREADS=%(threads)d\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "cd %(pwd)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"
        lines_pbs += "\n"
        lines_pbs += "mpirun -np %(cores)d --bind-to none --map-by ppr:%(ppn_use)d:node:pe=%(threads)d %(exepath)s %(exeinput)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"

    elif init_env.get_host() == "BlueWaters":
        lines_pbs = ""
        lines_pbs += "#!/bin/bash\n"
        lines_pbs += "\n"
        lines_pbs += "#PBS -A baec\n"
        lines_pbs += "#PBS -q %(queue)s\n"% pbs_dict
        lines_pbs += "#PBS -m ea\n"
        lines_pbs += "#PBS -M zjyx1991@foxmail.com\n"
        lines_pbs += "#PBS -j oe\n"
        lines_pbs += "#PBS -l walltime=%(time)s\n"% pbs_dict
        lines_pbs += "#PBS -l nodes=%(nodes)d:ppn=32:xe\n"% pbs_dict
        lines_pbs += "#PBS -N %(name)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "source /opt/modules/default/init/bash\n"
        lines_pbs += "module swap PrgEnv-cray PrgEnv-gnu\n"
        lines_pbs += "module list\n"
        lines_pbs += "\n"
        lines_pbs += "export OMP_NUM_THREADS=%(threads)d\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "export MPICH_MAX_THREAD_SAFETY=serialized\n"
        lines_pbs += "export OMP_WAIT_POLICY=passive\n"
        lines_pbs += "export MPICH_ENV_DISPLAY=1\n"
        lines_pbs += "export MPICH_ALLREDUCE_NO_SMP=1\n"
        lines_pbs += "ulimit -a\n"
        lines_pbs += "export CRAY_CUDA_PROXY=1\n"
        lines_pbs += "export MPICH_UNEX_BUFFER_SIZE=362914560\n"
        lines_pbs += "export MPICH_MAX_SHORT_MSG_SIZE=3200\n"
        lines_pbs += "\n"
        lines_pbs += "cd %(pwd)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"
        lines_pbs += "\n"
        lines_pbs += "aprun -n %(cores)d -N %(ppn_use)d -d %(threads)d -cc numa_node %(exepath)s %(exeinput)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"

    with open('pbs.rmg', 'wb') as f:
        f.write(lines_pbs)

def PBSRun(init_env, pbs_conf):

    # submit pbs
    if pbs_conf._params['is_submit']:
        print "Submitting jobs...\n"
        os.system('qsub pbs.rmg')
    
    
    with open('pbs.rmg', 'rb') as f:
        lines_pbs = f.readlines()
    
    with open('%s'% pbs_conf._params['exeinput'], 'rb') as f:
        lines_in = f.readlines()
    
    lines_conf = ''
    lines_conf += '#! /bin/bash'+'\n\n'
    lines_conf += 'Computer name: %s'%init_env.get_host() + '\n\n'
    lines_conf += '*'*80+'\n'
    lines_conf += '*'+' '*30+'PBS LINES: %6d'%len(lines_pbs)+' '*31+'*\n'
    lines_conf += '*'*80+'\n\n'
    lines_conf += '-'*80+'\n'
    lines_conf += ''.join(lines_pbs)
    lines_conf += '-'*80+'\n\n'
    lines_conf += '*'*80+'\n'
    lines_conf += '*'+' '*29+'INPUT LINES: %6d'%(len(lines_in))+' '*30+'*\n'
    lines_conf += '*'*80+'\n\n'
    lines_conf += '-'*80+'\n'
    lines_conf += ''.join(lines_in)
    lines_conf += '-'*80+'\n\n'
    
    # save configurations: including input file and pbs file
    i = 0
    while os.path.isfile('runconf.%02d'%(i)):
        i += 1
    
    with open('runconf.%02d'% i, 'wb') as f:
        f.write(lines_conf)

    # echo pbs.rmg to screen
    print "PBS configurations:\n"
    print "-"*60
    print "%s"% ''.join(lines_pbs)
    print "-"*60

if __name__ == "__main__":

    print '\n'

    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        filename = 'pbs.conf'

    if not os.path.isfile(filename):
        print("PBS conf file not found, exit.")
        sys.exit(1)

    init_env = InitEnv()
    pbs_conf = ConfParser(filename)
    # print pbs_conf._params
    validate_params(pbs_conf, init_env)
    #print pbs_conf._params

    write_pbs(init_env, pbs_conf)

    PBSRun(init_env, pbs_conf)
