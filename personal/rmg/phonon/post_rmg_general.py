#!/usr/bin/python2


'''
    Phonon Calculation script for RMGDFT:
    read log files generated by RMGDFT, calculate force constant matrix
    and then get phonon dispersion
'''


# Update logs:

'''

    v5.5: Mar/09/2016
        delete set_cutoff function, alternatively do this in 
            super2prim function:

    v5.4: Mar/05/2016
        rewrite plot function;
        rewrite all force matrix in n_prim*n format;
        rewrite functions' parameters passing method;

    v5.3: Feb/22/2016
        add get_WholeMat function for sym_opr case;
        revised functions for setting kpoints;

    v5.2:
        add self-consistency in sym process;
        fix bug of cutoff distance when it is larger than half of length;
          basically is super2prim function;
   
    v5.1:
        add central-force model in sym process;
   
    v5:
        rewrite all codes in functions;
        add sym function for the whole matrix;
        add dos calculation;
        revise the search function;
        replace count_repeated function with built-in function;
'''


import os
import sys
import time
import cmath
import matplotlib.pyplot as plt
import numpy as np
from math import *




###############################################################################
#
#   Pre part: get dicts, setup kpoints
#
###############################################################################


#read original logfile data in dict format:
def get_dict(file):

    global n_super, pos, length_a_super, length_b_super, length_c_super

    with open(file) as dict_file:
        all_lines = dict_file.readlines()

    for i in range(len(all_lines)):

        if "Atomic Species Information" in all_lines[i]:
            for j in range(i,len(all_lines)):
                if "Atomic symbol" in all_lines[j]:

                    dict_code = int(all_lines[j-2].split()[1])
                    dict_species = all_lines[j].split()[-1]
                    dict_mass = float(all_lines[j+2].split()[-2])

                    atoms_dict.append([dict_code,dict_species,dict_mass])

        #number of total atoms
        if "Number of ions" in all_lines[i]:
            n_super = int(all_lines[i].split()[-1])

        #lattice vectors, for tetragonal
        if "Basis vectors" in all_lines[i]:
            length_a_super = float(all_lines[i+1].split()[2])
            length_b_super = float(all_lines[i+2].split()[3])
            length_c_super = float(all_lines[i+3].split()[4])

        #initial ionic positions
        if "INITIAL IONIC" in all_lines[i]:
            for j in range(n_super):
                species_code.append(int(all_lines[i+j+3].split()[0]))

                pos.append([])
                for k in range(3):
                    tmp = (float(all_lines[i+j+3].split()[k+1]))
                    pos[j].append(tmp)

    return


#set up k-points
def set_kpoints():

    global k_vec, k_plt, k_tag, k_tag_pos, G

    k_vec = [] #vector k
    k_plt = [] #scalar k, for plotting use
    k_tag = [] #tag of special kpoints, like Gamma
    k_tag_pos = [0.0] #pos of kpoint tage, 0.0 is the starting pos

    #define how many kpoints in a block to be calculated
    k_den = 20

    G = [ 2.0*pi / (length_a_super/na), 
          2.0*pi / (length_b_super/nb), 
          2.0*pi / (length_c_super/nc)] #reciprocal lattice vector

    #turning k-points, in relative units
    #TODO: find a better way to do this, define kpoint name here
#    k_turn_dict = {
#              "L"     : [0.5,0.5,0.5],
#              "Gamma" : [0.0,0.0,0.0],
#              "K"     : [0.75,0.75,0.0],
#              "X"     : [1.0,1.0,0.0],
#              "W"     : [0.5,1.0,0.0],
#              "L"     : [0.5,0.5,0.5],
#              "K"     : [0.75,0.75,0.0],
#              "W"     : [0.5,1.0,0.0],
#              "X"     : [0.0,1.0,0.0],
#              "Gamma" : [0.0,0.0,0.0]
#             }
#
#    k_tag = [key for key in k_turn_dict]
#    k_turn = [k_turn_dict[key] for key in k_turn_dict]
    k_turn_set = [
              ["L"     , [0.5,0.5,0.5]],
              ["Gamma" , [0.0,0.0,0.0]],
              ["K"     , [0.75,0.75,0.0]],
              ["X"     , [1.0,1.0,0.0]],
              ["W"     , [0.5,1.0,0.0]],
              ["L"     , [0.5,0.5,0.5]],
              ["K"     , [0.75,0.75,0.0]],
              ["W"     , [0.5,1.0,0.0]],
              ["X"     , [0.0,1.0,0.0]],
              ["Gamma" , [0.0,0.0,0.0]]
             ]

    k_tag = [k_turn_set[i][0] for i in range(len(k_turn_set))]
    k_turn = [k_turn_set[i][1] for i in range(len(k_turn_set))]


    n_block = [k_den]*len(k_turn)

    for i in range(1,len(k_turn)):
        tmp = sqrt((G[0]*(k_turn[i][0]-k_turn[i-1][0]))**2+
                   (G[1]*(k_turn[i][1]-k_turn[i-1][1]))**2+
                   (G[2]*(k_turn[i][2]-k_turn[i-1][2]))**2)
        k_tag_pos.append(k_tag_pos[-1]+tmp)

    k_vec.append([k_turn[0][i]*G[i] for i in range(3)])
    k_plt.append(0.0)

    for i in range(len(k_turn)-1):

        k_start = [k_turn[i][j]*G[j] for j in range(3)]
        k_end  = [k_turn[i+1][j]*G[j] for j in range(3)]
        k_block_size = sqrt((k_end[0]-k_start[0])**2 +
                            (k_end[1]-k_start[1])**2 +
                            (k_end[2]-k_start[2])**2)

        for j in range(1,1+n_block[i]):
            k_vec.append([])
            for k in range(3):
                k_vec[-1].append(k_start[k]+j*(k_end[k]-k_start[k])/n_block[i])
            if i == 0:
                k_plt.append(j*k_block_size/n_block[i])
            else:
                k_plt.append(k_plt[-1] + k_block_size/n_block[i])

    return


#now consider the effect of nearest neighbors
def shell_effect():

    global FC

    count =  [[1 for i in range(n_super)]for j in range(n_prim)]

    for i in range(n_prim):
        for j in range(n_super):
            tmp_x = abs(pos[j][0]-pos[i][0])
            tmp_y = abs(pos[j][1]-pos[i][1])
            tmp_z = abs(pos[j][2]-pos[i][2])

            if abs(2*tmp_x-length_a_super) < 0.01 :
                count[i][j] *= 2
            if abs(2*tmp_y-length_b_super) < 0.01 :
                count[i][j] *= 2
            if abs(2*tmp_z-length_c_super) < 0.01 :
                count[i][j] *= 2


    for na in range(n_prim):
        for nb in range(n_super):
            if count[na][nb] != 1:
                for i in range(3):
                    for j in range(3):
                        FC[3*na+i][3*nb+j] /= count[na][nb]

    return


#setup large distanc'se interaction to 0
def set_cutoff():

    global FC

    f = open('cutoff_FC.dat','w')

    for i in range(n_prim):
        for j in range(n_super):


            tmp_x = (pos[i][0]-pos[j][0])%(length_a_super)
            tmp_y = (pos[i][1]-pos[j][1])%(length_b_super)
            tmp_z = (pos[i][2]-pos[j][2])%(length_c_super)

            if 2*tmp_x > length_a_super:
                tmp_x = length_a_super - tmp_x

            if 2*tmp_y > length_b_super:
                tmp_y = length_b_super - tmp_y

            if 2*tmp_z > length_c_super:
                tmp_z = length_c_super - tmp_z

            if tmp_x**2+tmp_y**2+tmp_z**2 > dist_cutoff**2:

                for l in range(3):
                    for m in range(3):
                        FC[3*i+l][3*j+m] = 0.0

    f.close()

    return


#find forces from a log file
def find_force(name):

    with open(name) as force_file:
        all_lines_find = force_file.readlines()

    result = []
    find_flag = 0
    #must be counted from the LAST line to ensure this is the final force
    for i in range(len(all_lines_find)-1,-1,-1):
        if 'movable' in all_lines_find[i]:
            find_flag = 1
            for j in range(i+1,i+n_super+1):
                tmp_x = float(all_lines_find[j].split()[7])
                tmp_y = float(all_lines_find[j].split()[8])
                tmp_z = float(all_lines_find[j].split()[9])
                result.extend([tmp_x,tmp_y,tmp_z])
            break
    if not find_flag:
        print 'Error: can not find forces from log files!'
    return result


#cal mass matrix
def mass_matrix():

    m_atom = [0.0]*n_super
    result = [[0.0 for i in range(3*n_super)]for j in range(3*n_super)]

    for i in range(n_super):
        for j in range(len(atoms_dict)):
            if species_code[i] == atoms_dict[j][0]:
                m_atom[i] = atoms_dict[j][2]

    for i in range(3*n_super):
        for j in range(3*n_super):
            mass_sq = m_atom[int(i/3)]*m_atom[int(j/3)]
            result[i][j] = sqrt(mass_sq)

    return result



#read symm opr files
def get_SymmOpr(file_so):

    global rot, trans

    rot, trans = [], []

    with open(file_so) as f:
        all_lines = f.readlines()

    for i in range(len(all_lines)):
        if "sym operation" in all_lines[i]:

            rot.append([])
            trans.append([])

            for j in range(3):

                trans[-1].append(float(all_lines[i+2].split()[j-3]))

                rot[-1].append([])
                for k in range(3): #should this always be integer?
                    rot[-1][-1].append(int(all_lines[i+1].split()[3*j+k+2]))

            #tmp_tran = [float(all_lines[i+2].split()[j-3]) for j in range(3)]
            #tmp_rot = 
    return




###############################################################################

#  Main part:
#   data processing, to get a primitive matrix

###############################################################################





# Use symm opr to get whole matrix
def get_WholeMat():

    global FC

    # the initial two atoms are 0 and nb; after apply Symm Opr S,
    # atom 0 will be na, and atom nb will be nb_so.
    FC_0_nb = [[complex(0.0,0.0)for i in range(3)]for j in range(3)]

    # need to locate the atom, not just n_moved+1
    # also both n_moved and n_prim need to add 1
    for na in range(n_moved,n_prim):
        # count how many nb_so per line, should equal n for every na;
        count = 0
        for nb in range(n_super):
            # convert rotation list in matrix form
            mat_rot = np.asmatrix(rot[na])

            x_nb_so = (rot[na][0][0]*pos[nb][0] +
                       rot[na][0][1]*pos[nb][1] +
                       rot[na][0][2]*pos[nb][2] +
                       trans[na][0])

            y_nb_so = (rot[na][1][0]*pos[nb][0] +
                       rot[na][1][1]*pos[nb][1] +
                       rot[na][1][2]*pos[nb][2] +
                       trans[na][1])

            z_nb_so = (rot[na][2][0]*pos[nb][0] +
                       rot[na][2][1]*pos[nb][1] +
                       rot[na][2][2]*pos[nb][2] +
                       trans[na][2])

            # search in the supercell to find nb_so
            for k in range(n_super):
#                delta_r2 = (x_nb_so-pos[k][0])**2 +\
#                           (y_nb_so-pos[k][1])**2 +\
#                           (z_nb_so-pos[k][2])**2
#
#                length_a_sq = length_a_super**2
#                length_b_sq = length_b_super**2
#                length_c_sq = length_c_super**2

                x_mod = ((x_nb_so-pos[k][0])**2)/(length_a_super**2) 
                y_mod = ((y_nb_so-pos[k][1])**2)/(length_b_super**2) 
                z_mod = ((z_nb_so-pos[k][2])**2)/(length_c_super**2) 

#                cond_a = x_mod < 0.1 or x_mod > length_a_super**2-0.1
#                cond_b = y_mod < 0.1 or y_mod > length_b_super**2-0.1
#                cond_c = z_mod < 0.1 or z_mod > length_c_super**2-0.1

                cond_a = abs(x_mod-round(x_mod)) < 0.001
                cond_b = abs(y_mod-round(y_mod)) < 0.001
                cond_c = abs(z_mod-round(z_mod)) < 0.001

                if cond_a and cond_b and cond_c:
                    nb_so = k
                    count += 1
                    break;

            for i in range(3):
                for j in range(3):
                    FC_0_nb[i][j] = FC[i][3*nb+j]

            #convert list to matrix
            mat_FC_0_nb = np.asmatrix(FC_0_nb)

            FC_na_nbso = np.mat(np.zeros((3,3)))

            FC_na_nbso = mat_rot*mat_FC_0_nb*(mat_rot.I)

            for i in range(3):
                for j in range(3):
                    FC[3*na+i][3*nb_so+j] = np.array(FC_na_nbso)[i][j]


        if count != n_super:
            print ("Warning: For atom[%3d], can not find all image atoms!\n"%(na))
 

    return


#symmetrize the whole matrix with translational symmetry, FC_ix_(jy+R) = FC_(ix-R)_jy
#i,j in primitive cell, R is connecting vectors
#NOTE: THIS PART IS NOT NECESSARY, MAY INCREASE ACCURACY OF FC MATRIX
def sym_FC():

    global FC

    flag_found = [0 for i in range(n_super)]

    #create all vectors connecting different prim cells
    R = []

    for i in range(na):

        R_x = i*length_a_super/na

        for j in range(nb):

            R_y = j*length_b_super/nb

            for k in range(nc):

                R_z = k*length_c_super/nc

                R.append([R_x, R_y, R_z])

    # x <==> s, y <==> t
    for s in range(n_prim):
        for t in range(n_prim): 
        #t means the possible atoms with R displacement;chosen s and t

            for ir in range(na*nb*nc):
                R_x = R[ir][0]
                R_y = R[ir][1]
                R_z = R[ir][2]

                xs_mod = (pos[s][0] - R_x)%(length_a_super)
                ys_mod = (pos[s][1] - R_y)%(length_b_super)
                zs_mod = (pos[s][2] - R_z)%(length_c_super)

                xt_mod = (pos[t][0] + R_x)%(length_a_super)
                yt_mod = (pos[t][1] + R_y)%(length_b_super)
                zt_mod = (pos[t][2] + R_z)%(length_c_super)

                t_flag, s_flag = 0, 0
                for search in range(n_super):
                    #search for s-R
                    if not s_flag:
                        conds_x = (pos[search][0]-xs_mod)**2 < 0.1
                        conds_y = (pos[search][1]-ys_mod)**2 < 0.1
                        conds_z = (pos[search][2]-zs_mod)**2 < 0.1
    
                        if conds_x and conds_y and conds_z:
                            s_new = search
                            s_flag += 1
    
                    #search for t+R
                    if not t_flag:
                        condt_x = (pos[search][0]-xt_mod)**2 < 0.1
                        condt_y = (pos[search][1]-yt_mod)**2 < 0.1
                        condt_z = (pos[search][2]-zt_mod)**2 < 0.1
    
                        if condt_x and condt_y and condt_z:
                            t_new = search
                            t_flag += 1
                
                tmp_avg = [[0.0 for i in range(3)]for j in range(3)]

#                #following applying for n*n FC matrix
#                for i in range(3):
#                    for j in range(3): #make sure that FC[3*s_new][] is not 0
#                        tmp_sym[i][j] = 0.5*(FC[3*s+i][3*t_new+j]+FC[3*s_new+i][3*t+j])
#
#                for i in range(3):
#                    for j in range(3):
#                        FC[3*s+i][3*t_new+j] = tmp_sym[i][j]
#                        FC[3*t_new+j][3*s+i] = FC[3*s+i][3*t_new+j]
#                        FC[3*t+j][3*s_new+i] = tmp_sym[i][j]
#                        FC[3*s_new+i][3*t+j] = tmp_sym[i][j]

                #apply for n_prim*n_super FC matrix
                for i in range(3):
                    for j in range(3):

                        tmp_1 = FC[3*s+i][3*t_new+j]
                        tmp_2 = FC[3*t+j][3*s_new+i]

                        tmp_avg[i][j] = 0.5*(tmp_1+tmp_2)

                for i in range(3):
                    for j in range(3):
                        FC[3*s+i][3*t_new+j] = tmp_avg[i][j]
                        FC[3*t+j][3*s_new+i] = tmp_avg[i][j]


    return


# find pairs which are in the cutoff distance
def nzp():

    global non_zero_pair

    for i in range(n_prim):
        for j in range(n_super):


            tmp_x = (pos[i][0]-pos[j][0])%(length_a_super)
            tmp_y = (pos[i][1]-pos[j][1])%(length_b_super)
            tmp_z = (pos[i][2]-pos[j][2])%(length_c_super)

            if 2*tmp_x > length_a_super:
                tmp_x = length_a_super - tmp_x

            if 2*tmp_y > length_b_super:
                tmp_y = length_b_super - tmp_y

            if 2*tmp_z > length_c_super:
                tmp_z = length_c_super - tmp_z

            if tmp_x**2+tmp_y**2+tmp_z**2 > dist_cutoff**2:

                non_zero_pair[i][j] = 0 # not pair

    return


# another version of ASR; apply for n_prim*n_super matrix
def rmg_asr_v2():

    global FC

    for na in range(n_prim):

        #make the diagonal block 0
        for ix in range(3):
            for iy in range(3):
                FC[3*na+ix][3*na+iy] = 0.0

        for nb in range(n_super):
            if nb != na:
                for i in range(3):
                    for j in range(3):
                        FC[3*na+i][3*na+j] -= FC[3*na+i][3*nb+j]

    return


#Use ASR on FC; apply for n_super*n_super matrix
def rmg_asr():

    global FC

    tmp = [[[[0 for i in range(n)]for j in range(n)]for k in range(3)]for l in range(3)]
    #convert from FC to tmp
    for i in range(3):
        for j in range(3):
            for na in range(n):
                for nb in range(n):
                    tmp[i][j][na][nb] = FC[3*na+i][3*nb+j]
    #impose
    for i in range(3):
        for j in range(3):
                for na in range(n):
                    sum = 0.0
                    for nb in range(n):
                        if na != nb:
                            sum += tmp[i][j][na][nb]
                    tmp[i][j][na][na] = -sum
    #convert from tmp back to FC
    for i in range(3):
        for j in range(3):
            for na in range(n):
                for nb in range(n):
                    FC[3*na+i][3*nb+j] = tmp[i][j][na][nb]

    return



#convert supercell matrix to primitive cell matrix
#version 2 just goes through all atoms in supercell
def super2prim_v2():

    global FC_prim


    A = np.mat([[a1[0],a2[0],a3[0]],
                [a1[1],a2[1],a3[1]],
                [a1[2],a2[2],a3[2]]])

    for s in range(n_prim): # we move s
        for t in range(n_prim):

#   TODO: if the structure is good enough, i.e, used repeated prim cells,
        #then we should use this simple version
#            for ir in range(na*nb*nc):#maybe need to rewrite a function
#
#                s_super = index_prim[s] + ir*n_prim

            for ir in range(n_super):

                delta_x = pos[ir][0] - pos[s][0]
                delta_y = pos[ir][1] - pos[s][1]
                delta_z = pos[ir][2] - pos[s][2]

                delta = [[delta_x/(length_a_super/na)],
                         [delta_y/(length_b_super/nb)],
                         [delta_z/(length_c_super/nc)]]

                index_A = (A.I)*delta

                # check whether if index_A is integer
                flag_int = 0
                for i in range(len(index_A)):
                    if abs(index_A[i]-round(index_A[i])) > 0.01:
                        flag_int += 1
                if flag_int: continue

                s_super = ir

                # find a better way to find closest image atom
                x_tmp = pos[s_super][0] - pos[t][0]
                if x_tmp > 0.5*length_a_super:
                    x_tmp -= length_a_super
                elif x_tmp < -0.5*length_a_super:
                    x_tmp += length_a_super

                y_tmp = pos[s_super][1] - pos[t][1]
                if y_tmp > 0.5*length_b_super:
                    y_tmp -= length_b_super
                elif y_tmp < -0.5*length_b_super:
                    y_tmp += length_b_super

                z_tmp = pos[s_super][2] - pos[t][2]
                if z_tmp > 0.5*length_c_super:
                    z_tmp -= length_c_super
                elif z_tmp < -0.5*length_c_super:
                    z_tmp += length_c_super

                if x_tmp**2 + y_tmp**2 + z_tmp**2 > dist_cutoff**2: 
                    continue

                for n_kpt in range(n_kpoints):

                    phase_imag = (k_vec[n_kpt][0]*(x_tmp)+
                                  k_vec[n_kpt][1]*(y_tmp)+
                                  k_vec[n_kpt][2]*(z_tmp))

                    phase_factor = cmath.exp(complex(0.0, phase_imag))

                    for i_tmp in range(3):#phi_A_A'; 
                        for j_tmp in range(3):

                            tmp = FC[3*t+j_tmp][3*s_super+i_tmp]*phase_factor

                            FC_prim[n_kpt][3*t+j_tmp][3*s+i_tmp] += tmp

    return


#return the number of nearest neighbors
def count_repeated(na,nb):

    count =  1

    tmp_x = abs(pos[na][0]-pos[nb][0])
    tmp_y = abs(pos[na][1]-pos[nb][1])
    tmp_z = abs(pos[na][2]-pos[nb][2])

    if abs(2*tmp_x-length_a_super) < 0.01 :
        count *= 2
    if abs(2*tmp_y-length_b_super) < 0.01 :
        count *= 2
    if abs(2*tmp_z-length_c_super) < 0.01 :
        count *= 2

    return count


#return the nearest imaginary atom's position
def nearest_pos(na,nb):
#na=s_super, nb=t
    min_dist2 = 10000
    result = []

    x_tmp = (pos[na][0] - pos[nb][0])#%(length_a_super)
    y_tmp = (pos[na][1] - pos[nb][1])#%(length_b_super)
    z_tmp = (pos[na][2] - pos[nb][2])#%(length_c_super)

    for i in range(-1,2):
        x_new = x_tmp + length_a_super*i
        for j in range(-1,2):
            y_new = y_tmp + length_b_super*j
            for k in range(-1,2):
                z_new = z_tmp + length_c_super*k

                tmp = x_new**2+y_new**2+z_new**2
                if tmp < min_dist2:
                    min_dist2 = tmp
                    result.append([x_new,y_new,z_new])

    return result[-1]


#self-consistence of ASR
def post_asr_self():

    global FC, non_zero_pair

    delta = [[0.0 for i in range(3)]for j in range(3)]
    fc_avg = [[0.0 for i in range(3)]for j in range(3)]    

    for n_diag in range(n_prim):

        # careful about -1 here; must exclude it self
        amount_non_zero = np.sum(non_zero_pair[n_diag]) - 1
        for i in range(3):
            for j in range(3):
                # be careful about the position of i and j here
                # since diagonal part will add a constantt delta, 
                # here we need to minus this constant in
                # all off-diagonal parts to hold ASR;
                fc_1 = FC[3*n_diag+i][3*n_diag+j]
                fc_2 = FC[3*n_diag+j][3*n_diag+i]

                fc_diff = fc_1 - fc_2
                delta[i][j] = 0.5*fc_diff/amount_non_zero

                fc_avg[i][j] = 0.5*(fc_1+fc_2)

        # impose the diff on off_diag blocks
        for n_sc in range(n_super):
            if non_zero_pair[n_diag][n_sc] and n_sc != n_diag:
                for i in range(3):
                    for j in range(3):
                        FC[3*n_diag+i][3*n_sc+j] += delta[i][j]

        #impose on the diag blocks
        for i in range(3):
            for j in range(3):
                FC[3*n_diag+i][3*n_diag+j] = fc_avg[i][j]

    return
 

#test if ASR is satisfied
def check_asr():

    global FC

    tmp = [[0.0 for i in range(3)]for j in range(3*n_prim)]
    asr_error = [0 for i in range(n_prim)]
    for na in range(n_prim):
        for nb in range(n_super):
            for i in range(3):
                for j in range(3):
                    tmp[3*na+i][j] += FC[3*na+i][3*nb+j]

    for n_tmp in range(n_prim):
        for i in range(3):
            for j in range(3):
                if abs(tmp[3*n_tmp+i][j]) > 0.01:
                    asr_error[n_tmp]= 1
            
    for i in range(n_prim):
        if asr_error[i]:
            print ('ASR error for atom[%3d]:\n'%(i))
            for j in range(3):
                for k in range(3):
                    print ('%12.7f'%(tmp[3*i+j][k])),
                print '\n'
            print '\n\n\n\n'

    return






###############################################################################

#   post process:
#               plot and write

###############################################################################





#cal dynamic matrix and phonons
def get_phonon(n_kpt):

    global freq, w2_sorted

    #calculate the asymmetric degree
    asymm = 0.0
    for i in range(3*n_prim):
        for j in range(i):

            diff_sym = FC_prim[n_kpt][i][j] - FC_prim[n_kpt][j][i]
            asymm += abs(diff_sym.real)
            diff_sym = FC_prim[n_kpt][i][j] + FC_prim[n_kpt][j][i]
            asymm += abs(diff_sym.imag)

    if asymm > 0.01:

        tmp = n_kpt, asymm
        print ('Warning: Asymmetric degree of kpoint [%3d] = %7.4f\n'%(tmp))

    for i in range(3*n_prim):
        for j in range(3*n_prim):
            dyn_mat[n_kpt][i][j] = FC_prim[n_kpt][i][j]/mass_mat[i][j]

#            # make dyn mat Hermitian
#            tmp_real = 0.5*(FC_prim[n_kpt][i][j].real+
#                            FC_prim[n_kpt][j][i].real)/mass_mat[i][j]
#            tmp_imag = FC_prim[n_kpt][i][j].imag/mass_mat[i][j]

#            dyn_mat[n_kpt][i][j] = complex(tmp_real, tmp_imag)

#            dyn_mat[n_kpt][i][j].imag = FC_prim[n_kpt][i][j].imag/mass_mat[i][j]
                                            
#            dyn_mat[n_kpt][i][j] *=0.5;
#            dyn_mat[n_kpt][i][j] +=np.conjugate(FC_prim[n_kpt][j][i])/mass_mat[i][j]
            

#find the eigenvalue of dyn_mat matrix
    w2 = np.linalg.eig(dyn_mat[n_kpt])

    w2_sorted = np.sort(w2[0])

    for i in range(3*n_prim):
        freq[i][n_kpt] = cmath.sqrt(w2_sorted[i])*const

    return


# plot for phonon
def ph_plt():

#    plt.figure(figsize=(10,10))
    for i in range(3*n_prim):
        plt.plot(k_plt,freq[i],'r')
    plt.xlabel('K-point')
    plt.ylabel('Frequency/THz')
    plt.xlim(0.0,k_plt[-1])
    if freq_cutoff:
        plt.ylim(0.0,freq_cutoff)
    for i in range(len(k_tag_pos)):
        plt.axvline(x=k_tag_pos[i],color='b')
    plt.xticks(k_tag_pos,k_tag)
#    plt.xticklabels(k_tag)
    plt.grid()
    plt.savefig('phonon_silicon')


#    plt.show()

    return


#function to calculate DOS
def rmg_dos():
 

    with open('FC_asr') as f:
        all_lines = f.readlines()


    #read FC from log file
    FC_dos = [[0.0 for i in range(3*n_super)]for j in range(3*n_prim)]
    for i in range(len(all_lines)):
        if 'Block' in all_lines[i]:
            row = int(filter(str.isdigit, all_lines[i].split()[-2]))
            col = int(filter(str.isdigit, all_lines[i].split()[-1]))

            for j in range(block_size):
                for k in range(block_size):
                    FC_dos[block_size*row+j][block_size*col+k] = float(all_lines[i+j+1].split()[k])

    k_vec_dos = [] #vector k  
    k_den = 9  
   
    G = [ 2.0*pi / (length_a_super/na),   
          2.0*pi / (length_b_super/nb),   
          2.0*pi / (length_c_super/nc)] #reciprocal lattice vector                         
                                                                                        
    for i in range(k_den):                                                              
        k_x = G[0]*(i+1.0)/(k_den+1.0)-0.5*G[0]                                         
        for j in range(k_den):                                                          
            k_y = G[1]*(j+1.0)/(k_den+1.0)-0.5*G[1]
            for k in range(k_den):
                k_z = G[2]*(k+1.0)/(k_den+1.0)-0.5*G[2]
   
                k_vec_dos.append([k_x,k_y,k_z])
                if k_x**2+k_y**2+k_z**2 < 0.00001: 
                    locate = len(k_vec)-1                                               
                                                                                        
    n_kpoints = len(k_vec)

    # for each kpoint, allocate a matrix
    FC_prim_dos = [[[0.0 for i in range(3*n_prim)]for j in range(3*n_prim)]for k in range(n_kpoints)]

    super2prim_v2()

    #calculate dos
    dyn_mat_dos = [[[0.0 for i in range(3*n_prim)]for j in range(3*n_prim)]for k in range(n_kpoints)]
    mass_mat = mass_matrix()
    freq_dos = [[0.0 for i in range(n_kpoints)]for j in range(3*n_prim)]

    for i in range(n_kpoints):
        for j in range(3*n_prim):
            for k in range(3*n_prim):
                dyn_mat_dos[i][j][k] = FC_prim_dos[i][j][k]/mass_mat[j][k]

    for i in range(n_kpoints):
        w2 = np.linalg.eig(dyn_mat_dos[i])
        w2_sorted = np.sort(w2[0])

        for j in range(3*n_prim):
            freq[j][i] = cmath.sqrt(w2_sorted[j])*const


    n_freq = 4000

    freq_cutoff = 1000
    ebroading = 10

    weights = [1.0/n_kpoints]*n_kpoints

    dos = [0.0]*n_freq

    k_plt = [0.0]*n_freq
    for i in range(n_freq):

        k_plt[i] = 4000.0*i/n_freq

        for j in range(3*n_prim):

            for k in range(n_kpoints):

                tmp = freq[j][k].real - k_plt[i]
                dos[i] += np.exp(-tmp**2/ebroading**2)/(1.7724*ebroading)

    for i in range(n_freq):
        dos[i] /= (1000.0*k_plt[i])

    plt.plot(k_plt,dos,'r')
    plt.xlim(0.0,freq_cutoff)
    plt.xlabel('Wavenumber/$cm^{-1}$')
    plt.ylabel('Intensity')
    plt.grid()
    plt.savefig('dos_ab')

    #print the freq in a list

    f = open('freq_lst','w')
    for i in range(n_kpoints):
        f.write('freq for kpoint[%6d]\n'%(i))
        for j in range(3*n_prim):
            f.write('%4d    %12.7f + %12.7f\n'%(j,freq[j][i].real,freq[j][i].imag))
        f.write('\n\n')

    f.close()

    plt.show()
    

    return




###############################################################################

#   public function

###############################################################################




# print big matrix in blocks; TODO:n_super is not necessary, to be deleted
def print_matrix(file_name,matrix_name,block_size):


    if len(matrix_name)%(block_size) or len(matrix_name[0])%(block_size):
        print ('Warning: bad block_size printing matrix [%10s]!\n'%(file_name))

    f = open(file_name,'w')
    # block numbers per col
    n_row = int(len(matrix_name)/block_size)
    # block numbers per row
    n_col = int(len(matrix_name[0])/block_size)

    #a complex matrix
    if type(matrix_name[0][0])==complex:

        f.write('Real Part:\n\n\n')
        for i in range(n_row):
            for j in range(n_col):
    
                f.write('Block number: [%3d, %3d]\n'%(i,j))
    
                for na in range(block_size):
                    for nb in range(block_size):
    
                        tmp = matrix_name[i*block_size+na][j*block_size+nb].real
                        f.write('%12.7f'%(tmp))
                    f.write('\n')
                f.write('\n\n\n\n')
    
        f.write('Imag Part:\n\n\n')
        for i in range(n_row):
            for j in range(n_col):
    
                f.write('Block number: [%3d, %3d]\n'%(i,j))
                for na in range(block_size):
                    for nb in range(block_size):
    
                        tmp = matrix_name[i*block_size+na][j*block_size+nb].imag
                        f.write('%12.7f'%(tmp))
                    f.write('\n')
                f.write('\n\n\n\n')

    #matrix is a real matrix
    else:

        for i in range(n_row):
            for j in range(n_col):
    
                f.write('Block number: [%3d, %3d]\n'%(i,j))
    
                for na in range(block_size):
                    for nb in range(block_size):
    
                        tmp = matrix_name[i*block_size+na][j*block_size+nb]
                        f.write('%12.7f'%(tmp))
                    f.write('\n')
                f.write('\n\n\n\n')

    f.close()

    return


#function to print time
def print_time(rmg_process):

    global rmg_time

    rmg_time.append(time.time())
    dt = rmg_time[-1] - rmg_time[-2]

    print ('Time for [%20s] process:  [%5d] s\n'%(rmg_process,dt))

    return



#symmetrize the matrix
def sym_mat(mat_):

    global FC

    for i in range(3*n_prim):
        for j in range(i):
            tmp = (FC[i][j]+FC[j][i])/2.0
            FC[i][j] = tmp
            FC[j][i] = tmp

    return


#check parameters
def check_param():

#check cutoff distantce
    min_half = min(length_a_super/2.0, length_b_super/2.0, length_c_super/2.0)
    if dist_cutoff < min_half:
        print 'Warning: cutoff distantce too large!\n'

#check block_size
    if (3*n)%(block_size):
        print 'Warning: bad block_size for supercell!\n'

    if (3*n_prim)%(block_size):
        print 'Warning: bad block_size for primitive cell!\n'

    return


#check symmetry of the matrix
def check_sym():

    global FC

    tmp = 0.0
    for i in range(3*n_prim):
        for j in range(i):
            tmp += abs(FC[i][j].real-FC[j][i].real)

    return tmp


#main function
def main():

    return



if __name__ == "__main__":


    prefix  = 'in.ab'
    disp    = 0.02
    n_prim  = 16
    na, nb, nc = 4, 4, 4 #how many prim cells in a super cell
    unit_freq = 'THz'
    const   = 3.2170*10000/(2*3.1415927) # in units of cm-1
#    const = 961.58/(2*3.1415927) #in units of THz
    pos, species, species_code, atoms_dict = [], [], [], []
    #base vectors for primitive cell
#    a1 = [  0.5,   0.5,    0]
#    a2 = [  0.5,   0,    0.5]
#    a3 = [    0,   0.5,  0.5]
    a1 = [  0.5,   0.5,    0]
    a2 = [  0.5,   0,    0.5]
    a3 = [    0,   0.5,  0.5]
    dist_cutoff = 10.0
    flag_SymmOpr = 1 #whether if we used Symm Opr to get whole matrix
    n_moved = 1

    #for self_consistence loop of ASR and symm;
    # vice proportional to the number of prim cells 
    self_consistence_criteria = 1e-10
    freq_cutoff = 0 #set up the cutoff freq




    print '\n\n\n\n'
    rmg_time = []
    rmg_time.append(time.time())


    i_max = int(na/2)+1
    j_max = int(nb/2)+1
    k_max = int(nc/2)+1




###############################################################################

# pre processing:
#       read log files, get FC

###############################################################################



    if not flag_SymmOpr:
        n_moved = n_prim

#TODO:set up file path, then use variable to replace them
    dict_file = ('/home/zjyx/chips/2016/feb/silicon_test/pre/2.SymmOpr/%s.in.00.log'%(prefix))
    get_dict(dict_file)

    print_time('get_dict')

#check whether if parameters are set up in a meaningful way
#    check_param()

    set_kpoints()

    n_kpoints = len(k_vec)
    freq = [[0.0 for i in range(n_kpoints)]for j in range(3*n_prim)]

    file_SymmOpr = '/home/zjyx/chips/2016/feb/silicon_test/pre/2.SymmOpr/symmetry_operator.dat'
    get_SymmOpr(file_SymmOpr)
    print_time('get_SymmOpr')

#read FC logfile data, get a matrix of 3*(3*64)
    Force_neg, Force_pos = [], []


############## block for defining parameters ######################

    #the dimension of FC should be compatible with primitive cell 
    FC = [[0.0 for i in range(3*n_super)]for j in range(3*n_prim)]

    FC_prim = [[[complex(0.0,0.0) for i in range(3*n_prim)]
                                  for j in range(3*n_prim)]
                                  for k in range(n_kpoints)]

    dyn_mat = [[[0.0 for i in range(3*n_prim)]
                     for j in range(3*n_prim)]
                     for k in range(n_kpoints)]

    non_zero_pair = [[1 for i in range(n_super)]for j in range(n_prim)]

############## end of this block ##################################

#TODO: need to add a basis dir, all others will be included
    for i in range(3*n_moved):

        file_neg = ("/home/zjyx/chips/2016/feb/silicon_test/run/output/%s.0.%d.00.log"%(prefix,i))
        file_pos = ("/home/zjyx/chips/2016/feb/silicon_test/run/output/%s.1.%d.00.log"%(prefix,i))
        Force_neg.append(find_force(file_neg))
        Force_pos.append(find_force(file_pos))

        for j in range(3*n_super):
                FC[i][j] = -(Force_pos[i][j]-Force_neg[i][j])/(2.0*disp)

    print_time('get_FC')


#    for i in range(n):
#        for j in range(i):
#            for na in range(3):
#                for nb in range(3):
#                    FC[3*i+na][3*j+nb] = FC[3*j+nb][3*i+na]


#    for i in range(3*n):
#        for j in range(i):
#            FC[i][j] = FC[j][i] # sym the mat

    print_matrix('FC_init',FC,6)




################################################################################

# data processing:
#   get whole FC matrix;
#   Effects of shells; 
#   sym operation to get whole matrix

################################################################################



    #TODO: rebuild the structure here, messy
    if flag_SymmOpr:
        get_WholeMat()
        print_time('get_WholeMat')
        print_matrix('FC_get_WholeMat',FC,6)

    shell_effect();
    print_time('shell_effect'); #    print_matrix('FC_shell',FC,6)

    sym_FC();    print_time('Sym_FC');    print_matrix('FC_sym_FC',FC,6)

    set_cutoff();    print_time('set_cutoff');    print_matrix('FC_set_cutoff',FC,6)

    # Use Acoustic Sum Rules on FC matrix
    rmg_asr_v2();
    print_time('rmg_asr_v2');#    print_matrix('FC_asr_v2',FC,n,12)


    nzp();
    print_time('non_zero_pair')

#    post_asr_self();
    print_time('post_asr_self')



    print ('Asymmetric degree is: [%12.7f]\n'%(check_sym()))

    loop_count = 0

    while not check_sym():# > self_consistence_criteria:

        loop_count += 1
        print ('Loop [%4d], now asym_degree = [%12.7f]...'%(loop_count,check_sym())),
        sym_FC()
        rmg_asr_v2()
        post_asr_self()
        print_time(' this loop ')


    check_asr()
    print ('Asymmetric degree after self-consistency is: [%12.7f]\n'%(check_sym()))

    print_matrix('FC_asr',FC,6)



################################################################################

#   post processing:
#       calculating dynamic matrix and find frequencies, plot

################################################################################

    


    mass_mat = mass_matrix()

    super2prim_v2()
    print_time('super2prim_v2')

    #TODO: Logic is too bad, need to be improved

    #calculate phonons
    for n_kpt in range(n_kpoints):
        get_phonon(n_kpt)


    #write freq
    f_freq = open('%s.freq'%(prefix),'w')
    for n_kpt in range(n_kpoints):

        tmp_kpt = n_kpt, k_vec[n_kpt][0], k_vec[n_kpt][1], k_vec[n_kpt][2]
        f_freq.write('kpoint [%4d]:[%8.4f, %8.4f,%8.4f]\n\n'%(tmp_kpt))

        for i in range(3*n_prim):
            freq_real = freq[i][n_kpt].real
            freq_imag = freq[i][n_kpt].imag
            f_freq.write('%4d %10.4f + %7.4fi\n'%(i,freq_real,freq_imag))
        f_freq.write('\n\n\n\n')

    f_freq.close()

    f_xmgr = open('%s.freq.xmgr'%(prefix),'w')
    for i in range(n_kpoints):
        for j in range(3*n_prim):
            f_xmgr.write('%12.7f    %12.7f\n'%(k_plt[i],freq[j][i].real))
    f_xmgr.close()

    print_matrix('FC_prim_gamma',FC_prim[20],6)

    #plot
    ph_plt()

    end = time.time()

    print ('Total time is: [%5d] seconds\n'%(end-rmg_time[0]))
