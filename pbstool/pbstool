#! /usr/bin/env python

'''
Program: generate and submit pbs files for RMG/qe, etc.
         save run configurations for later debug
    zjyx, @2017/02, ORNL

ChangeLogs:
    1. remove queue tags, which will be determined by walltime and host
        automatically.
    2. change param's 'type' from type+_type+__type to [type, type];
       change format of str to 'str'
    3. add support for qe
    4. add module options;
       add suppot for vasp
    5. add check_input function

TODO:
    add support for castep

USAGE:
    pbstool ($pbs.conf file)
    where pbstool should be in system's environment varialbe $PATH, and 
    $pbs.conf is the control file for this script, which should follow the 
    following format:
    -----------------------------------------------------------------------
    # required
    NODES       = 16
    TIME        = 100 20 # in units of hrs, mins
    EXEINPUT    = rmg.in
    EXEPATH     = /home/z8j/bin/rmg-cpu
    THREADS     = 2
    
    # optional
    NAME        = surface-pbe221-rlx
    IS_SUBMIT   = true
    QUEUE       = None
    EXEOUTPUT   = none
    MODULE      = PrgEnv-gnu
    MODULE      = fftw
    ------------------------------------------------------------------------
    If $pbs.conf not specified, pbs.conf will be read by default.

'''

import os
import sys
from ExeIn import *

# params properties
# if param is list, then type should be [1D type, 2D type]
param_prop = {
    'nodes':     {'required': True,  'type': 'int',   'default': None},
    'time' :     {'required': True,  'type': ['list', 'int'], 'default': None},
    'exeinput':  {'required': True,  'type': 'str',   'default': None},
    'exepath':   {'required': True,  'type': 'str',   'default': None},
    'threads':   {'required': False, 'type': 'int',   'default': 1},
    'name':      {'required': False, 'type': 'str',   'default': 'test'},
    'queue':     {'required': False, 'type': 'str',   'default': 'debug'},
    'is_submit': {'required': False, 'type': 'bool',  'default': True},
    'cores':     {'required': False, 'type': 'int',   'default': None},
    'exeoutput': {'required': False, 'type': 'str',   'default': None},
    'module':    {'required': False, 'type': 'str',   'default': []}
    }

# system properties
sys_prop = {
    'Cades': {'all_queues': ['batch', 'long'], 'time_threshold': 30},
    'BlueWaters': {'all_queues': ['debug', 'normal', 'high'], 'time_threshold': 30}
    }

# environment variables
class InitEnv:
    def __init__(self):
        self._user = None
        self._host = None
        self._pwd  = None
        self._home_path = None

        self._set_all()

    def _set_all(self):
        self._set_user()
        self._set_host()
        self._set_pwd()
        self._set_home_path()

    def _set_user(self):
        import getpass
        self._user = getpass.getuser()

    def get_user(self):
        return self._user

    def _set_host(self):
        import socket
        hostname = socket.gethostname()
        if 'or-condo' in hostname:
            self._host = 'Cades'
        elif 'h2o' in hostname:
            self._host = 'BlueWaters'
        elif 'titan' in hostname:
            self._host = 'Titan'
        else:
            self._host = hostname
            print 'Warning: Unknown host.'

    def get_host(self):
        return self._host

    def _set_pwd(self):
        self._pwd = os.getcwd()

    def get_pwd(self):
        return self._pwd

    def _set_home_path(self):
        self._home_path = os.path.expanduser('~')

    def get_home_path(self):
        return self._home_path

# add set and get functions here, cause it may be modified
class ConfParser:
    def __init__(self, filename=None):
        self._confs = { 'nodes':    param_prop['nodes']['default'],
                        'time':     param_prop['time']['default'],
                        'exeinput': param_prop['exeinput']['default'],
                        'exepath':  param_prop['exepath']['default'],
                        'module':   param_prop['module']['default']
        }

        self._params = {}

        if filename is not None:
            self.read_file(filename)

        self.parse_conf()

    def setting_error(self, msg):
        print(msg)
        print("Please check the setting tags.")
        sys.exit(1)

    def read_file(self, filename):
        confs = self._confs
        with open(filename, 'rb') as f:
            lines_conf = f.readlines()
        for line in lines_conf:
            line_tmp = line.split('#')[0]
            if line_tmp == '':
                continue
            if line_tmp.find('=') != -1:
                left, right = [x.strip() for x in line_tmp.split('=')]
                left = left.lower()
                if left != "module":
                    confs[left] = right
                else:
                    confs[left].append(right)

    def parse_conf(self):
        confs = self._confs

        for conf_key in confs.keys():
            if conf_key == 'exepath':
                self.set_param('exepath', confs['exepath'])
                break

        for conf_key in confs.keys():
            if conf_key == 'nodes':
                self.set_param('nodes', confs['nodes'])
            elif conf_key == 'time':
                self.set_param('time', confs['time'])
            elif conf_key == 'exeinput':
                self.set_param('exeinput', confs['exeinput'])
            elif conf_key == 'exepath': # to avoid unrecognized tag error
                pass
            elif conf_key == 'threads':
                self.set_param('threads', confs['threads'])
            elif conf_key == 'name':
                self.set_param('name', confs['name'])
            elif conf_key == 'is_submit':
                self.set_param('is_submit', confs['is_submit'])
            elif conf_key == 'queue':
                self.set_param('queue', confs['queue'])
            elif conf_key == 'exeoutput':
                self.set_param('exeoutput', confs['exeoutput'])
            elif conf_key == 'module':
                self.set_param('module', confs['module'])
            else:
                print("Warning! Unrecoginized settings: %s"% conf_key)

    def set_param(self, key, val):
        _param = param_prop[key]
        # TODO: need to detect if a default value has been modified intendly
        if _param['required'] and val == _param['default']:
            msg = "Error: required tags %s not found."% key.upper()
            self.setting_error(msg)
        #consider canceling this part, check mandatory part one by one manually TODO
        if key == 'cores':
            self._set_cores(val)
        elif key == 'name':
            self._set_name(val)
        elif key == 'is_submit':
            self._set_is_submit(val)
        elif key == 'nodes':
            self._set_nodes(val)
        elif key == 'time':
            self._set_time(val) 
        elif key == 'exeinput':
            self._set_exeinput(val) 
        elif key == 'exepath':
            self._set_exepath(val) 
        elif key == 'exeoutput':
            self._set_exeoutput(val) 
        elif key == 'threads':
            self._set_threads(val) 
        elif key == 'queue':
            self._set_queue(val) 
        elif key == 'module':
            self._set_module(val) 
        else:
            msg = "Error: %s type tag could not be identified."% key.upper()
            self.setting_error(msg)

        #if not isinstance(_param['type'], list):
        #    if _param['type'].lower() == 'str':
        #        self._params[key] = str(val)
        #    elif _param['type'].lower() == 'int':
        #        self._params[key] = int(val)
        #    elif _param['type'].lower() == 'float':
        #        self._params[key] = float(val)
        #    elif _param['type'].lower() == 'bool':
        #        if val.lower() == 'false':
        #            self._params[key] = False
        #        elif val.lower() == 'true':
        #            self._params[key] = True
        #elif len(_param['type']) == 2:
        #    if _param['type'][0] == 'list':
        #        _2type = eval(_param['type'][1])
        #        self._params[key] = [_2type(x) for x in val.split()]
        #else:
        #    msg = "Error: %s type tag could not be identified."% key.upper()
        #    self.setting_error(msg)

    def _set_nodes(self, val):
        self._params['nodes'] = int(val)

    def _set_time(self, val):
        self._params['time'] = [int(ele) for ele in val.split()]

    def _set_exeinput(self, val):
        self._params['exeinput'] = val

    def _set_exeoutput(self, val):
        self._params['exeoutput'] = str(val)

    def _set_exepath(self, val):
        self._params['exepath'] = str(val)
        if 'vasp' in self._params['exepath'].lower():
            #print "hhah"
            vasp_in = ['INCAR', 'POSCAR', 'POTCAR', 'KPOINTS']
            #self.set_param('exeinput', vasp_in)
            self._confs['exeinput'] = vasp_in

    def _set_module(self, val):
        #if 'module' not in self._params:
        #    self._params['module'] = []

        #self._params['module'].append(str(val))
        self._params['module'] = val

    def _set_threads(self, val):
        self._params['threads'] = int(val)

    def _set_name(self, val):
        self._params['name'] = str(val)

    def _set_is_submit(self, val):
        if val.lower() in ['false', 'f']:
            self._params['is_submit'] = False
        elif val.lower() in ['true', 't']:
            self._params['is_submit'] = True
        else:
            msg = "Error: Unknown value for tag IS_SUBMIT, exit."
            self.setting_error(msg)

    def _set_queue(self, val):
        self._params['queue'] = str(val).lower()

    def _set_cores(self, val=None):
        if val:
            self._params['cores'] = val
        else:
            self._params['cores'] = 32*self._params['nodes']/self._params['threads']

    def validate_params(self):
        pass

    def validate_name(self, pwd):
        name = self._params['name']
        self._params['name'] = name + '@' + pwd

    def validate_is_submit(self):
        is_submit = self._params['is_submit']
        exename = self._params['exename']
        if not is_submit:
            print "%s: Debug mode, job will not be submitted.\n"% exename.upper()
        
    def validate_threads(self, ppn=32):
        threads  = self._params['threads']
        if ppn%(threads):
            msg = "Error: OMP_NUM_THREADS is not set correctly, exit."
            self.setting_error(msg)

    def validate_cores(self):
        cores =  self._params['cores']
        nodes =  self._params['nodes']
        if cores > 32*nodes:
            msg =  "Error: Cores exceeds maximum limit set by nodes, exit."
            self.setting_error(msg)

    def validate_exepath(self):
        rmg_exe_list = ['rmg-cpu']
        qe_exe_list = ['pw.x', 'phon']
        vasp_exe_list = ['vasp_std', 'vasp_ncl', 'vasp_gam']
        exepath  = pbs_conf._params['exepath']
        exename  = os.path.basename(exepath)
        if not os.path.isfile(exepath):
            msg = "Error: Executable %s does not exist, exit."% exepath
            self.setting_error(msg)
        if exename in rmg_exe_list:
            self._params['exename'] = 'RMG'
            #print "EXE name: %s"% 'RMG'
        elif exename in qe_exe_list:
            self._params['exename'] = 'QE'
            #print "EXE name: %s"% 'QE'
        elif exename in vasp_exe_list:
            self._params['exename'] = 'VASP'
            #print "EXE name: %s"% 'VASP'

    def validate_module(self):
        from subprocess import Popen, PIPE
        p = Popen(['module avail'], stdout=PIPE, stderr=PIPE, shell=True)
        _out, _err = p.communicate()
        _outerr = _out + _err

        modules = self._params['module']
        #print modules
        #all_mods = subprocess.call()
        # cades module avail will be printed to stderr, thus you cannot get stdout
        #all_mods = os.popen('module avail').read()
        for _module in modules:
            if (not os.path.isfile(_module)) and ("%s"% _module not in _outerr):
                print "Warning: module %s does not exist."% _module

    def validate_exeinput(self):
        exeinput = self._params['exeinput']
        exename = self._params['exename']
        if exename == 'VASP':
            for _vasp_in in exeinput:
                if not os.path.isfile(_vasp_in):
                    msg = "Error: %s input file %s not found, exit."%(exename, exeinput)
                    self.setting_error(msg)
        elif not os.path.isfile(exeinput):
            msg = "Error: %s input file %s not found, exit."%(exename, exeinput)
            self.setting_error(msg)

        self.check_exeinput(exename, exeinput)

    def check_exeinput(self, exename, exeinput):
        if exename == "RMG":
            in_args = RmgIn(exeinput)
            validate_rmgin(in_args)
        elif exename == 'qe':
            in_args = QeIn(exeinput)

    def validate_exeoutput(self):
        exeoutput = self._params['exeoutput']
        if self._params['exename'] == 'VASP':
            pass
        elif exeoutput.lower() == 'none':
            exeoutput_pre = self._params['exeinput'].split('.in')[0]
            i = 0
            while os.path.isfile("%s.%02d.out"%(exeoutput_pre, i)):
                i += 1

            exeoutput = "%s.%02d.out"%(exeoutput_pre, i)
            #if i:
            #    print "Warning: Executable output file(%s) already exists, reset to ."% exeoutput

            self._params['exeoutput'] = exeoutput

    def validate_queue(self, host):
        time = self._params['time']
        queue = self._params['queue']
        if host == "Cades":
            self._validate_queue_cades(queue, time)
        elif host == "BlueWaters":
            self._validate_queue_bw(queue, time)
        else:
            msg = "Unknown host: %s, exit"% host
            self.setting_error(msg)

    def _validate_queue_cades(self, queue, time):
        all_queues = ['batch', 'long']
        if queue != 'none' and queue not in all_queues:
            msg = "Queue error, exit."
            pbs_conf.setting_error(msg)
        if time[0] > 48:
            queue = all_queues[1]
            print "Walltime exceeds 48 hrs, queue is set to %s.\n"% queue
        else:
            queue = all_queues[0]
            print "Walltime is under 48 hrs, queue is set to %s.\n"% queue
        self._params['queue'] = queue

    def _validate_queue_bw(self, queue, time):
        all_queues = ['debug', 'normal', 'high']
        if queue != 'none' and queue not in all_queues:
            msg = "Queue error, exit."
            pbs_conf.setting_error(msg)
        # ignore if queue is high
        if queue != 'high':
            if time[0]*60+time[1] <= 30:
                queue = all_queues[0]
                print "Walltime is under 30 mins, queue is set to %s.\n"% queue
            else:
                queue = all_queues[1]
                print "Walltime exceeds 30 mins, queue is set to %s.\n"% queue
        self._params['queue'] = queue


# check if settings make sense, and correct them
def validate_params(pbs_conf, init_env):

    # if not set in pbs.conf, then use its default value defined
    for key in param_prop:
        if not key in pbs_conf._params:
            pbs_conf.set_param(key, param_prop[key]['default'])

    # DO NOT change orders of following lines
    pbs_conf.validate_exepath()
    pbs_conf.validate_name(init_env.get_pwd())
    pbs_conf.validate_is_submit()
    pbs_conf.validate_cores()
    pbs_conf.validate_threads()
    # BEWARE: exepath must be in front of exeinput
    pbs_conf.validate_exeinput()
    pbs_conf.validate_exeoutput()
    pbs_conf.validate_module()
    pbs_conf.validate_queue(init_env.get_host())


def write_pbs(init_env, pbs_conf):
    threads  = pbs_conf._params['threads']
    nodes    = pbs_conf._params['nodes']
    time     = pbs_conf._params['time']
    name     = pbs_conf._params['name']
    queue    = pbs_conf._params['queue']
    exepath  = pbs_conf._params['exepath']
    exeinput = pbs_conf._params['exeinput']
    exeoutput= pbs_conf._params['exeoutput']
    exename  = pbs_conf._params['exename']
    cores    = pbs_conf._params['cores']
    module   = pbs_conf._params['module']

    # convert to pbs format
    pwd         = init_env.get_pwd()
    ppn_use     = divmod(32, threads)[0]
    time_pbs    = "%02d:%02d:00"%(time[0], time[1])

    module_pbs = ""
    for _module in module:
        module_pbs += "module load %s\n"%_module

    pbs_dict = {'queue':        queue,
                'time':         time_pbs,
                'nodes':        nodes,
                'name':         name,
                'threads':      threads,
                'pwd':          pwd,
                'cores':        cores,
                'exepath':      exepath,
                'exeinput':     exeinput,
                'module':       module_pbs,
                'exeoutput':    exeoutput,
                'ppn_use':      ppn_use}

    if init_env.get_host() == "Cades":
        lines_pbs = ""
        lines_pbs += "#!/bin/bash\n"
        lines_pbs += "\n"
        lines_pbs += "#PBS -A sns\n"
        lines_pbs += "#PBS -q %(queue)s\n"% pbs_dict
        lines_pbs += "#PBS -m ea\n"
        lines_pbs += "#PBS -M zjyx1991@foxmail.com\n"
        lines_pbs += "#PBS -j oe\n"
        lines_pbs += "#PBS -l qos=condo\n"
        lines_pbs += "#PBS -W group_list=cades-virtues\n"
        lines_pbs += "#PBS -l walltime=%(time)s\n" % pbs_dict
        lines_pbs += "#PBS -l nodes=%(nodes)d:ppn=32\n"% pbs_dict
        lines_pbs += "#PBS -N %(name)s\n" % pbs_dict
        lines_pbs += "\n"
        lines_pbs += "%(module)s"% pbs_dict
        #if exename == "QE":
        #    lines_pbs += "module load /software/tools/modules/env/cades-virtues\n"
        #    lines_pbs += "module load /software/tools/modules/compilers/intel/2016.1\n"
        #    lines_pbs += "module load /software/tools/modules/utils/intel/mkl/2016.1\n"
        #    lines_pbs += "module load /software/tools/modules/mpi/openmpi/intel/1.10.2\n"
        #    lines_pbs += "module load /software/user_tools/current/modules/cades-virtues/env/intel\n"
        #    lines_pbs += "module load /software/user_tools/current/modules/cades-virtues/espresso/5.4.0\n"
        lines_pbs += "module list\n"
        lines_pbs += "\n"
        lines_pbs += "export OMP_NUM_THREADS=%(threads)d\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "cd %(pwd)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"
        lines_pbs += "\n"
        if exename == 'RMG':
            lines_pbs += "mpirun -np %(cores)d --bind-to none --map-by ppr:%(ppn_use)d:node:pe=%(threads)d %(exepath)s %(exeinput)s\n"% pbs_dict
        elif exename == 'QE':
            lines_pbs += "mpirun -np %(cores)d --bind-to none --map-by ppr:%(ppn_use)d:node:pe=%(threads)d %(exepath)s < %(exeinput)s > %(exeoutput)s\n"% pbs_dict
        elif exename == 'VASP':
            lines_pbs += "mpirun -np %(cores)d --bind-to none --map-by ppr:%(ppn_use)d:node:pe=%(threads)d %(exepath)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"

    elif init_env.get_host() == "BlueWaters":
        lines_pbs = ""
        lines_pbs += "#!/bin/bash\n"
        lines_pbs += "\n"
        lines_pbs += "#PBS -A baec\n"
        lines_pbs += "#PBS -q %(queue)s\n"% pbs_dict
        lines_pbs += "#PBS -m ea\n"
        lines_pbs += "#PBS -M zjyx1991@foxmail.com\n"
        lines_pbs += "#PBS -j oe\n"
        lines_pbs += "#PBS -l walltime=%(time)s\n"% pbs_dict
        lines_pbs += "#PBS -l nodes=%(nodes)d:ppn=32:xe\n"% pbs_dict
        lines_pbs += "#PBS -N %(name)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "source /opt/modules/default/init/bash\n"
        if exename == "RMG":
            lines_pbs += "module swap PrgEnv-cray PrgEnv-gnu\n"
        elif exename == "QE":
            lines_pbs += "module swap PrgEnv-cray PrgEnv-intel\n"
        lines_pbs += "module list\n"
        lines_pbs += "\n"
        lines_pbs += "export OMP_NUM_THREADS=%(threads)d\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "export MPICH_MAX_THREAD_SAFETY=serialized\n"
        lines_pbs += "export OMP_WAIT_POLICY=passive\n"
        lines_pbs += "export MPICH_ENV_DISPLAY=1\n"
        lines_pbs += "export MPICH_ALLREDUCE_NO_SMP=1\n"
        lines_pbs += "ulimit -a\n"
        lines_pbs += "export CRAY_CUDA_PROXY=1\n"
        lines_pbs += "export MPICH_UNEX_BUFFER_SIZE=362914560\n"
        lines_pbs += "export MPICH_MAX_SHORT_MSG_SIZE=3200\n"
        lines_pbs += "\n"
        lines_pbs += "cd %(pwd)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"
        lines_pbs += "\n"
        if exename == "RMG":
            lines_pbs += "aprun -n %(cores)d -N %(ppn_use)d -d %(threads)d -cc numa_node %(exepath)s %(exeinput)s\n"% pbs_dict
        elif exename == 'QE':
            lines_pbs += "aprun -n %(cores)d -N %(ppn_use)d -d %(threads)d -cc numa_node %(exepath)s < %(exeinput)s > %(exeoutput)s\n"% pbs_dict
        elif exename == 'VASP':
            lines_pbs += "aprun -n %(cores)d -N %(ppn_use)d -d %(threads)d -cc numa_node %(exepath)s\n"% pbs_dict
        lines_pbs += "\n"
        lines_pbs += "date\n"

    with open('pbs.%s'% exename.lower(), 'wb') as f:
        f.write(lines_pbs)


def PBSRun(init_env, pbs_conf):

    with open('pbs.%s'% pbs_conf._params['exename'].lower(), 'rb') as f:
        lines_pbs = f.read()

    if pbs_conf._params['exename'] == 'VASP':
        lines_in = ""
        for _input in pbs_conf._params['exeinput']:
            lines_in += "\n%s\n"% _input
            with open(_input, 'rb') as f:
                lines_in += f.read()
    else:
        with open('%s'% pbs_conf._params['exeinput'], 'rb') as f:
            lines_in = f.read()
    
    lines_conf = ''
    lines_conf += '#! /bin/bash'+'\n\n'
    lines_conf += 'Computer name: %s'%init_env.get_host() + '\n\n'
    lines_conf += '*'*80+'\n'
    lines_conf += '*'+' '*30+'PBS LINES: %6d'%len(lines_pbs)+' '*31+'*\n'
    lines_conf += '*'*80+'\n\n'
    lines_conf += '-'*80+'\n'
    lines_conf += lines_pbs
    lines_conf += '-'*80+'\n\n'
    lines_conf += '*'*80+'\n'
    lines_conf += '*'+' '*29+'INPUT LINES: %6d'%(len(lines_in))+' '*30+'*\n'
    lines_conf += '*'*80+'\n\n'
    lines_conf += '-'*80+'\n'
    lines_conf += lines_in
    lines_conf += '-'*80+'\n\n'
    
    # submit pbs
    if pbs_conf._params['is_submit']:
        print "Submitting jobs..."
        os.system('qsub pbs.%s'% pbs_conf._params['exename'].lower())

        # save configurations: including input file and pbs file
        i = 0
        while os.path.isfile('runenv.%02d'%(i)):
            i += 1
    
        with open('runenv.%02d'% i, 'wb') as f:
            f.write(lines_conf)

    # echo pbs conf to screen
    print "\nPBS configurations:"
    print "-"*60
    print "%s"% ''.join(lines_pbs)
    print "-"*60

if __name__ == "__main__":

    print '\n'

    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        filename = 'pbs.conf'

    if not os.path.isfile(filename):
        print("PBS conf file not found, exit.")
        sys.exit(1)

    init_env = InitEnv()
    pbs_conf = ConfParser(filename)
    # print pbs_conf._params
    validate_params(pbs_conf, init_env)
    #print pbs_conf._params

    write_pbs(init_env, pbs_conf)

    PBSRun(init_env, pbs_conf)
