#! /usr/bin/env python

'''
    Program: submit pbs jobs for virtues under limitation of procs etc

    TODO:
        1. try not to write and read qstat, it's not efficient
        2. Try to use case when judging limits types
        3. Merge all judgements like checkexit checkothers into 1 result
'''

import os
import sys
import time
import re
from subprocess import Popen, PIPE

# check if qsub.EXIT exists
def checkExit(exitfile="qsub.EXIT"):
    if os.path.isfile(exitfile) or os.path.isfile(os.path.join(pwd, exitfile)):
        msg = 'Exit file found, aborting....\n'
        print msg
        #os.system('echo %s >> %s'%(msg, ))
        sys.exit(0)


# check other jobs blocked or queued
def checkOthers(acct='sns'):
    check_others = Popen(['showq -w acct=%s'%acct], stdout=PIPE, stderr=PIPE, shell=True)
    others_out, others_err = check_others.communicate()
    others_oe_tmp = others_out + others_err
    others_oe = ''.join(others_oe_tmp).split('\n')
    #print others_oe[0:10]
    for i in range(len(others_oe)):
        if ' eligible job' in others_oe[i] and int(others_oe[i].split()[0]) != 0:
            for j in range(int(others_oe[i].split()[0])):
                if str(others_oe[i-j-2].split()[1]) != 'z8j':
                    return True


        if ' blocked job' in others_oe[i] and int(others_oe[i].split()[0]) != 0:
            for j in range(int(others_oe[i].split()[0])):
                if str(others_oe[i-j-2].split()[1]) != 'z8j' and str(others_oe[i-j-2].split()[2]) != "BatchHold":
                    return True

    return False

# for the whole acct
def get_qrh_procs(acct='sns'):
    check_acct = Popen(['showq -w acct=%s'%acct], stdout=PIPE, stderr=PIPE, shell=True)
    acct_out, acct_err = check_acct.communicate()
    acct_oe_tmp = acct_out + acct_err
    acct_oe = ''.join(acct_oe_tmp).split('\n')
    nact, nelg, nblk = 0, 0, 0
    for i in range(len(acct_oe)):
        if ' active job' in acct_oe[i]:
            nact = int(str(acct_oe[i]).split()[3])
        elif ' eligible job' in acct_oe[i] and int(acct_oe[i].split()[0]) != 0:
            for j in range(int(acct_oe[i].split()[0])):
                nelg += int(acct_oe[i-j-2].split()[3])
        elif ' blocked job' in acct_oe[i] and int(acct_oe[i].split()[0]) != 0:
            nblk = 0
            for j in range(int(acct_oe[i].split()[0])):
                nblk += int(acct_oe[i-j-2].split()[3])
    return nact+nelg+nblk

# read conf file
def read_conf(conf_file):
    with open(conf_file, 'rb') as f:
        conf_lines = f.readlines()
    for line in conf_lines:
        line = line.split('#')[0]
        if "exclude" in line.lower():
            values = line.split('=')[-1].split()
            pbs_conf['exclude'] = values
        elif "max_nodes" in line.lower():
            values = line.split('=')[-1]
            pbs_conf['max_nodes'] = int(values)
        elif "max_procs" in line.lower():
            values = line.split('=')[-1]
            #pbs_conf['max_acct_nodes'] = int(values)
            pbs_conf['max_procs'] = int(values)
        elif "max_acct_nodes" in line.lower():
            values = line.split('=')[-1]
            #pbs_conf['max_acct_nodes'] = int(values)
            pbs_conf['max_acct_nodes'] = int(values)
        elif "max_jobs" in line.lower():
            values = line.split('=')[-1]
            pbs_conf['max_jobs'] = int(values)
        elif "sleep" in line.lower():
            values = line.split('=')[-1]
            pbs_conf['sleep'] = float(values)
        elif "file_pbs" in line.lower():
            values = line.split('=')[-1]
            pbs_conf['file_pbs'] = str(values)
        elif "user_id" in line.lower():
            values = line.split('=')[-1].split()[0]
            pbs_conf['user_id'] = str(values)
        elif "ignore_if_existed" in line.lower():
            values = line.split('=')[-1].split()
            pbs_conf['ignore_if_existed'] = values

# get total number of current active procs
def get_queued_nodes():

    nodes_tmp = 0
    time_format='%Y%m%d%H%M%S'
    time_tmp = time.strftime(time_format, time.localtime())
    file_tmp = 'tmp.qi.%s'% time_tmp

    os.system("qstat -u z8j > %s"%(file_tmp))

    with open('%s'% file_tmp) as f:
        lines = f.readlines()

    for line in lines:
        if ('z8j' in line) and (line.split()[-2] == 'Q'):
            nodes_tmp += int(line.split()[5])

    os.system('rm %s'%(file_tmp))
    return nodes_tmp

# get total number of current jobs
def get_qrh_nodes_old():

    nodes_r, nodes_q, nodes_h = 0, 0, 0
    time_format='%Y%m%d%H%M%S'
    time_tmp = time.strftime(time_format, time.localtime())
    file_tmp = 'tmp.qi.%s'% time_tmp

    os.system("qstat -u z8j > %s"%(file_tmp))

    with open('%s'% file_tmp) as f:
        lines = f.readlines()

    for line in lines:
        if 'z8j' not in line:
            continue
        if line.split()[-2] == 'Q':
            nodes_q += int(line.split()[5])
        elif line.split()[-2] == 'R':
            nodes_r += int(line.split()[5])
        elif line.split()[-2] == 'H':
            nodes_h += int(line.split()[5])

    os.system('rm %s'%(file_tmp))
    return nodes_r+nodes_q+nodes_h

# get total number of current active procs

# get total number of current active procs
def get_running_nodes():

    nodes_tmp = 0
    time_format='%Y%m%d%H%M%S'
    time_tmp = time.strftime(time_format, time.localtime())
    file_tmp = 'tmp.qi.%s'% time_tmp

    os.system("qstat -u z8j > %s"%(file_tmp))

    with open('%s'% file_tmp) as f:
        lines = f.readlines()

    for line in lines:
        if ('z8j' in line) and (line.split()[-2] == 'R'):
            nodes_tmp += int(line.split()[5])

    os.system('rm %s'%(file_tmp))
    return nodes_tmp

# get total number of running/queued jobs
def get_num_jobs():

    jobs_tmp = 0
    time_format='%Y%m%d%H%M%S'
    time_tmp = time.strftime(time_format, time.localtime())
    file_tmp = 'tmp.qi.%s'% time_tmp

    os.system("qstat -u z8j > %s"%(file_tmp))

    with open('%s'% file_tmp) as f:
        lines = f.readlines()

    for line in lines:
        if ('z8j' in line):# and (line.split()[-2] == 'R' or line.split()[-2] == 'Q'):
           jobs_tmp += 1

    os.system('rm %s'%(file_tmp))
    return jobs_tmp

# read procs to be requested
def get_req_procs():

    with open(file_pbs) as f:
        lines = f.readlines()

    for line in lines:
        if 'nodes' in line and 'ppn' in line:
            key_words = line.split()[-1]
            break

    nodes = int(key_words.split(':')[0].split('=')[-1])
    ppn = int(key_words.split('=')[-1])

    req_procs = nodes*ppn

    return req_procs

# get total nodes in queue or running for the whole group
def getGroupNodes(acct = 'sns'):

    nodes_running, nodes_queued, nodes_blocked = 0,0,0
    time_format='%Y%m%d%H%M%S'
    time_tmp = time.strftime(time_format, time.localtime())
    file_tmp = 'tmp.qi.%s'% time_tmp

    os.system("showq -w acct=%s > %s"%(acct, file_tmp))

    with open('%s'% file_tmp) as f:
        lines = f.readlines()

    for i in range(len(lines)):
        line = lines[i]
        if 'in use' in line:
            nodes_running = int(line.split()[3])
        elif ' eligible jobs' in line:
            jobs_queued = int(line.split()[0])
            for j in range(jobs_queued):
                nodes_queued += int(lines[i-nodes_queued-1+j].split()[3])
        elif ' blocked jobs' in line:
            jobs_blocked = int(lines.split()[0])
            for j in range(jobs_blocked):
                nodes_blocked += int(lines[i-nodes_blocked-1+j].split()[3])

    os.system('rm %s'%(file_tmp))

    return nodes_running, nodes_queued, nodes_blocked

# check if the pbs file has already been submitted
def check_job_existed(job_to_sub):

    if job_to_sub not in running_jobs:
        return True
    else:
        return False

class PbsIn():
    def __init__(self, lines):
        self._set_methods = {'walltime': self._set_walltime,
                             'queue': self._set_queue,
                             'nodes': self._set_nodes,
                             'procs': self._set_procs,
                             'jobname': self._set_jobname}
        self._tags = {'walltime': None,
                      'queue': None,
                      'nodes': None,
                      'procs': None,
                      'jobname': None}

        self._collect(lines)

    def get_tags(self):
        return self._tags

    def _collect(self, lines):
        elements = []
        tag = None
        for line_tmp in lines:
            if 'PBS' in line_tmp:
                line = line_tmp.split('#')[1]
            else:
                line = line_tmp.split('#')[0]

            if len(line) < 2:
                continue

            if 'PBS' in line:
                if ('-l' in line) and ('walltime' in line):
                    line_replaced = line.replace('=', ' ').replace(':', ' ')
                    words = line_replaced.lower().split()
                elif ('-l' in line) and ('nodes' in line):
                    line_replaced = line.replace('=', ' ').replace(':', ' ')
                    words = line_replaced.lower().split()
                elif '-q' in line:
                    words = line.lower().split()
                elif '-N' in line:
                    words = line.lower().split()

            for val in words:
                if val.lower() in self._set_methods:
                    tag = val.lower()
                    elements[tag] = []
                elif tag is not None:
                    elements[tag].append(val)

        for tag in ['walltime', 'resources', 'name']:
            if tag not in elements:
                print ('%s is not found in the pbs file.'% tag)
                sys.exit(1)

        for tag, self._values in elements.iteritems():
            self._set_methods[tag]()

    def _set_walltime(self):
        walltime = [int(self._values[0]),
                    int(self._values[1]),
                    int(self._values[1])]
        self._tag['walltime'] = walltime

    def _set_resources(self):
        resources = [int(self._values[0]),
                     int(self._values[1])]
        self._tag['resources'] = resources

    def _set_queue(self):
        queue = self._values[0]
        self._tag['queue'] = queue

    def _set_jobname(self):
        jobname = self._values[0]
        self._tag['jobname'] = jobname

if __name__ == "__main__":

    pbs_conf = {"file_pbs": "pbs.sh",
                "exclude": None,
                "name_log": "log.pbs",
                "max_nodes": -1,
                "max_procs": -1,
                "max_acct_nodes": -1,
                "max_jobs": -1,
                "ignore_if_existed": None,
                "sleep": 0
                }

    # read control file
    if len(sys.argv) > 1:
        print "Use user defined qsub control file: %s\n"% sys.argv[-1]
        pbs_conf_file = sys.argv[-1]
        read_conf(pbs_conf_file)
    else:
        if os.path.isfile('qsub.conf'):
            print "Use default qsub control file in current working directory: %s\n"% 'qsub.conf'
            pbs_conf_file = "qsub.conf"
            read_conf(pbs_conf_file)
        else:
            print "Use program internal qsub parameters\n"

########################
# default variables
########################
    # set default time format
    time_format='%Y-%m-%d %X'
    submitted_job_counter = 0

    # log of qsub
    pwd = os.getcwd()
    file_log = os.path.join(pwd, pbs_conf['name_log'])

    # get all directories in pwd
    all_dir = []
    for (dirpath, dirnames, filenames) in os.walk(pwd):
        dirnames.sort()
        all_dir.extend(dirnames)
        break


########################
# submit jobs
########################
    for this_dir in all_dir:
        
        checkExit()

        # print current direcotry
        print "\nCurrent directory: %s"% this_dir

        # check if excluded by tag: exclude
        excluded = False
        if pbs_conf['exclude']:
            for this_exclude in pbs_conf['exclude']:
                if re.search(this_exclude, this_dir):
                    excluded = True

        if excluded:
            continue

        work_dir = os.path.join(pwd, this_dir)
        os.chdir(work_dir)

        # check if ignored by tag: ignored_if_existed
        if pbs_conf['ignore_if_existed']:
            for this_ignore in pbs_conf['ignore_if_existed']:
                for this_file in os.listdir(os.getcwd()):
                    if re.search(this_ignore, this_file):
                        excluded = True

        if excluded:
            continue

        # check if there are jobs hold or queued by others
        others_blocked = checkOthers()
        while others_blocked:
            time_tmp = time.strftime(time_format, time.localtime())
            sleep_msg = ("%s@%s: There are jobs blocked owned by others. Sleeping for [%4d] secs..."
                            %(time_tmp, this_dir, pbs_conf['sleep']))
            print sleep_msg
            os.system("echo %s >> %s"%(sleep_msg, file_log))
            time.sleep(pbs_conf['sleep']) 
            others_blocked = checkOthers()

        # decide which limitation case
        limit_case = 0 # no limit
        
        if pbs_conf['max_acct_nodes'] > 0 and pbs_conf['max_nodes'] < 0 and pbs_conf['max_jobs'] < 0:
            limit_case = 1
        elif pbs_conf['max_acct_nodes'] < 0 and pbs_conf['max_nodes'] > 0 and pbs_conf['max_jobs'] <0:
            limit_case = 2
        elif pbs_conf['max_acct_nodes'] < 0 and pbs_conf['max_nodes'] < 0 and pbs_conf['max_jobs'] >0:
            limit_case = 3
        elif pbs_conf['max_acct_nodes'] > 0 and pbs_conf['max_nodes'] > 0 and pbs_conf['max_jobs'] <0:
            limit_case = 4
        elif pbs_conf['max_acct_nodes'] > 0 and pbs_conf['max_nodes'] < 0 and pbs_conf['max_jobs'] >0:
            limit_case = 5
        elif pbs_conf['max_acct_nodes'] < 0 and pbs_conf['max_nodes'] > 0 and pbs_conf['max_jobs'] >0:
            limit_case = 6
        elif pbs_conf['max_acct_nodes'] > 0 and pbs_conf['max_nodes'] > 0 and pbs_conf['max_jobs'] >0:
            limit_case = 7
        # no limits at all
        if pbs_conf['max_procs'] < 0 and pbs_conf['max_jobs'] < 0:
            os.system('qsub %s'%( pbs_conf['file_pbs']))
        # limit max_nodes
        elif pbs_conf['max_procs'] > 0 and pbs_conf['max_jobs'] < 0:
            #queued_nodes = get_queued_nodes()
            #running_nodes = get_running_nodes()
            qrh_procs = get_qrh_procs()
            while qrh_procs > pbs_conf['max_procs']:
                time_tmp = time.strftime(time_format, time.localtime())
                sleep_msg = ('%s@%s: %d procs in use out of max limit %d. Sleeping for [%4d] secs...'
                            %(time_tmp, this_dir, qrh_procs, pbs_conf['max_procs'], pbs_conf['sleep']))
                print sleep_msg
                os.system("echo %s >> %s"%(sleep_msg, file_log))
                time.sleep(pbs_conf['sleep'])

                qrh_procs = get_qrh_procs()
                #queued_nodes = get_queued_nodes()
                #running_nodes = get_running_nodes()

            os.system('qsub %s'% pbs_conf['file_pbs'])
            sub_msg = ('Job for %s is submitted.'% this_dir)
            os.system("echo %s >> %s"%(sub_msg, file_log))
            # submitted jobs info delay
            time.sleep(30)
        # limit max jobs
        elif pbs_conf['max_procs'] < 0 and pbs_conf['max_jobs'] > 0:
            num_jobs = get_num_jobs()
            while num_jobs > pbs_conf['max_jobs']:
                time_tmp = time.strftime(time_format, time.localtime())
                sleep_msg = ('%s@%s: %d jobs running out of max limit %d. Sleeping for [%4d] secs...'
                            %(time_tmp, this_dir, num_jobs, pbs_conf['max_jobs'], pbs_conf['sleep']))
                print sleep_msg
                os.system("echo %s >> %s"%(sleep_msg, file_log))
                time.sleep(pbs_conf['sleep'])

                num_jobs = get_num_jobs()

            os.system('qsub %s'% pbs_conf['file_pbs'])
            sub_msg = ('Job for %s is submitted.'% this_dir)
            os.system("echo %s >> %s"%(sub_msg, file_log))
            # submitted jobs info delay
            time.sleep(30)
        # limit both
        else:
            queued_nodes = get_queued_nodes()
            running_nodes = get_running_nodes()
            num_jobs = get_num_jobs()
            while (queued_nodes + running_nodes) > pbs_conf['max_nodes'] or num_jobs > pbs_conf['max_jobs']:
                time_tmp = time.strftime(time_format, time.localtime())
                sleep_msg = ('%s@%s: nodes in use: %d, running jobs: %5d. Sleeping for [%4d] secs...'
                            %(time_tmp, this_dir, queued_nodes+running_nodes, num_jobs, pbs_conf['sleep']))
                print sleep_msg
                os.system("echo %s >> %s"%(sleep_msg, file_log))
                time.sleep(pbs_conf['sleep'])

                queued_nodes = get_queued_nodes()
                running_nodes = get_running_nodes()
                num_jobs = get_num_jobs()

            os.system('qsub %s'% pbs_conf['file_pbs'])
            sub_msg = ('Job for %s is submitted.'% this_dir)
            os.system("echo %s >> %s"%(sub_msg, file_log))
            # submitted jobs info delay
            time.sleep(30)

        submitted_job_counter += 1

    print ('\n\n\n All jobs submitted: %d\n'% submitted_job_counter)
    os.system("echo %s >> %s"%('Done!', file_log))
